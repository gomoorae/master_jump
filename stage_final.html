<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="version" content="1.0.1">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <title>ë¬´í˜¼ ë¹„ê²½: ìµœì¢… ë‚œê´€</title>
    
    <!-- PWA ë©”íƒ€ íƒœê·¸ -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="manifest.json">
    <style>
        @font-face {font-family: 'Dokdo'; src: url('assets/common/Dokdo-Regular.ttf') format('truetype'); font-weight: normal; font-style: normal; }
        body { 
            margin: 0; 
            background: #000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            width: 100vw;
            height: 100vh; 
            overflow: hidden; 
        }
        
        /* 16:9 ë¹„ìœ¨ ìœ ì§€ ì»¨í…Œì´ë„ˆ */
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 56.25vw; /* 16:9 */
            max-height: 100vh;
            max-width: 177.78vh; /* 16:9 */
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        
        canvas { 
            background: #0a0a0a; 
            border: 5px solid #5d4037; 
            box-shadow: 0 0 20px rgba(0,255,0,0.2); 
            cursor: pointer;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }
        
        /* ì‹œì‘ ì˜¤ë²„ë ˆì´ */
        #startOverlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
            font-family: 'Dokdo', cursive;
        }
        
        #startOverlay.hidden {
            display: none;
        }
        
        #startMessage {
            color: #ff4444;
            font-size: 120px;
            text-shadow: 0 0 30px #ff4444, 0 0 60px #ff4444;
            margin-bottom: 40px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        #startHint {
            color: #888;
            font-size: 45px;
            animation: blink 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        /* ì„¸ë¡œ ëª¨ë“œ ì•ˆë‚´ ë ˆì´ì–´ */
        #rotateOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.98);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: #fff;
            font-family: 'Dokdo', cursive;
        }
        
        #rotateIcon {
            font-size: 120px;
            margin-bottom: 30px;
            animation: rotateAnim 2s ease-in-out infinite;
        }
        
        #rotateText {
            font-size: 60px;
            color: #ff4444;
            text-shadow: 0 0 20px #ff4444;
        }
        
        @keyframes rotateAnim {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        
        @media (orientation: portrait) {
            #rotateOverlay {
                display: flex !important;
            }
        }
        
        /* ë’¤ë¡œê°€ê¸° í™•ì¸ íŒì—… */
        #backConfirmOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-family: 'Dokdo', cursive;
        }
        
        #backConfirmOverlay.show {
            display: flex;
        }
        
        #backConfirmBox {
            background: linear-gradient(145deg, #1a1a1a, #2d2d2d);
            border: 5px solid #ff4444;
            border-radius: 20px;
            padding: 50px 60px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.5);
        }
        
        #backConfirmMessage {
            color: #fff;
            font-size: 70px;
            margin-bottom: 50px;
            text-shadow: 0 0 20px #fff;
        }
        
        #backConfirmButtons {
            display: flex;
            gap: 30px;
            justify-content: center;
        }
        
        .backConfirmBtn {
            padding: 20px 50px;
            font-size: 50px;
            border: 3px solid;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Dokdo', cursive;
            background: rgba(0, 0, 0, 0.5);
        }
        
        #continueBtn {
            color: #ffcc00;
            border-color: #ffcc00;
        }
        
        #continueBtn:hover {
            background: #ffcc00;
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 30px #ffcc00;
        }
        
        #exitBtn {
            color: #ff4444;
            border-color: #ff4444;
        }
        
        #exitBtn:hover {
            background: #ff4444;
            color: #fff;
            transform: scale(1.05);
            box-shadow: 0 0 30px #ff4444;
        }
    </style>
</head>
<body>
    <!-- ì„¸ë¡œ ëª¨ë“œ ì•ˆë‚´ ë ˆì´ì–´ -->
    <div id="rotateOverlay">
        <div id="rotateIcon">ğŸ“±âœğŸ®</div>
        <div id="rotateText">ê¸°ê¸°ë¥¼ ê°€ë¡œë¡œ ëŒë ¤ì£¼ì„¸ìš”</div>
    </div>
    
    <!-- ë’¤ë¡œê°€ê¸° í™•ì¸ íŒì—… -->
    <div id="backConfirmOverlay">
        <div id="backConfirmBox">
            <div id="backConfirmMessage">ê²Œì„ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
            <div id="backConfirmButtons">
                <button id="continueBtn" class="backConfirmBtn">ê³„ì†í•˜ê¸°</button>
                <button id="exitBtn" class="backConfirmBtn">ë‚˜ê°€ê¸°</button>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- ì‹œì‘ ì˜¤ë²„ë ˆì´ -->
        <div id="startOverlay">
            <div id="startMessage">ìµœì¢… ë‚œê´€ ì‹œì‘</div>
            <div id="startHint">í™”ë©´ì„ í„°ì¹˜í•˜ì„¸ìš”...</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600; canvas.height = 900;

        // 1. ë°ì´í„° ê³„ìŠ¹
        const savedMaxJingi = parseInt(localStorage.getItem('maxJingi')) || 8;
        const savedRecoverThreshold = parseInt(localStorage.getItem('jingiRecoverThreshold')) || 180;

        // 2. ì—ì…‹ ë¡œë”©
        const imgs = {
            rising: new Image(), falling: new Image(), jumpEff: new Image(),
            trap: new Image(), deflect: new Image(), hitEff: new Image(),
            axe: new Image(), spear: new Image(), sword: new Image(),
            wall: new Image(), ceiling: new Image(), 
            optionBtn: new Image(), bgmOn: new Image(), bgmOff: new Image(),
            dead: new Image(), rightOut: new Image()
        };
        const CP = 'assets/common/';
        imgs.rising.src = CP+'rising_sheet.png'; imgs.falling.src = CP+'falling_sheet.png';
        imgs.jumpEff.src = CP+'jump_effect_sheet.png'; imgs.axe.src = CP+'axe.png';
        imgs.spear.src = CP+'spear.png'; imgs.sword.src = CP+'sword.png'; 
        imgs.trap.src = CP+'trap_asset.png'; imgs.deflect.src = CP+'deflect_sheet.png';
        imgs.hitEff.src = CP+'hit_effect_sheet.png'; imgs.wall.src = CP+'bg_wall_s3.png';
        imgs.ceiling.src = CP+'bg_ceiling.png'; imgs.optionBtn.src = CP+'option_btn.png';
        imgs.bgmOn.src = CP+'bgm_on.png'; imgs.bgmOff.src = CP+'bgm_off.png';
        imgs.dead.src = CP+'dead_sheet.png'; imgs.rightOut.src = CP+'right_out.png';

        // 3. ì‹œìŠ¤í…œ
        const bgm = new Audio(CP+'bgm.mp3'); bgm.loop = true;
        const gameOverSfx = new Audio(CP+'gameover.mp3');
        let volumeSteps = 4; bgm.volume = volumeSteps / 8; gameOverSfx.volume = bgm.volume;

        let isPaused = false; let isClear = false; let isFullyExited = false; let isGameOver = false;
        let gameStarted = false; // ê²Œì„ ì‹œì‘ ì—¬ë¶€
        let isFirstLoad = true; // ì²« ë¡œë“œì¸ì§€ í™•ì¸
        let shakeAmount = 0; let stageFrameCount = 0;
        const TOTAL_STAGE_TIME = 180 * 60;
        
        // deltaTime ê´€ë¦¬ (í”„ë ˆì„ ë ˆì´íŠ¸ ë…ë¦½ì ì¸ ì›€ì§ì„)
        let lastTime = performance.now();
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;

        const TRAP_HEIGHT = 80; const background = { wallX: 0, wallSpeed: 2, ceilingX: 0, ceilingSpeed: 8, trapX: 0 };
        const player = {
            x: 350, y: 100, drawWidth: 125, drawHeight: 125,
            hitboxWidth: 50, hitboxHeight: 90, hitboxOffsetX: 25, hitboxOffsetY: 15,
            vy: 0, gravity: 0.4, thrust: -1.2, isPressing: false,
            state: 'FALLING', currentFrame: 0, tickCount: 0, ticksPerFrame: 5, animDir: 1,
            frames: { RISING: 6, FALLING: 6, DEFLECT: 3, DEAD: 6 },
            ceilingStunTimer: 0, jingi: savedMaxJingi, maxJingi: savedMaxJingi, jingiRecoverTick: 0
        };

        const ui = {
            optBtn: { x: 20, y: 800, w: 70, h: 70 },
            jingiBar: { x: 30, y: 30, segW: 20, segH: 20, gap: 5, color: '#00ffcc' },
            volBar: { x: 700, y: 405, w: 320, h: 30, gap: 5 },
            soundIcon: { x: 580, y: 380, size: 80 }
        };

        let jumpEffects = []; let hitEffects = []; let obstacles = []; let obstacleTrails = []; let envParticles = [];

        function initGame() {
            isPaused = false; isClear = false; isGameOver = false; isFullyExited = false;
            
            // â˜… ì²« ë¡œë“œê°€ ì•„ë‹ˆë©´ (ì¬ë„ì „ì´ë©´) ë°”ë¡œ ì‹œì‘
            if (!isFirstLoad) {
                gameStarted = true;
                startOverlay.classList.add('hidden');
                if(volumeSteps > 0) { 
                    bgm.currentTime = 0; 
                    bgm.play().catch(() => {}); 
                }
            } else {
                gameStarted = false; // ì²« ë¡œë“œëŠ” ëŒ€ê¸°
            }
            
            stageFrameCount = 0; shakeAmount = 0;
            player.x = 350; player.y = 100; player.vy = 0; player.jingi = player.maxJingi;
            player.state = 'FALLING'; player.currentFrame = 0; obstacles = []; 
            obstacleTrails = []; envParticles = [];
        }
        
        // ì‹œì‘ ì˜¤ë²„ë ˆì´ í´ë¦­/í„°ì¹˜ ì´ë²¤íŠ¸
        const startOverlay = document.getElementById('startOverlay');
        function startGame() {
            isFirstLoad = false; // ì²« ë¡œë“œ ì™„ë£Œ
            gameStarted = true;
            startOverlay.classList.add('hidden');
            if(volumeSteps > 0) { 
                bgm.currentTime = 0; 
                bgm.play().catch(() => {}); 
            }
        }
        
        startOverlay.addEventListener('click', startGame);
        startOverlay.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startGame();
        });

        function createJumpEffect(px, py, pw, ph) { jumpEffects.push({ x: px + (pw/2)-65-15, y: py+ph-65-19, size: 130, currentFrame: 0, totalFrames: 6, tickCount: 0, ticksPerFrame: 3 }); }
        function createHitEffect(x, y) { hitEffects.push({ x: x, y: y - 50, size: 100, currentFrame: 0, totalFrames: 5, tickCount: 0, ticksPerFrame: 2 }); }
        function createEnvBurst(x, y, isCeiling) {
            if (envParticles.length > 200) return;
            for (let i = 0; i < 12; i++) { envParticles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: isCeiling ? (Math.random() * 5 + 2) : (Math.random() * -5 - 2), size: Math.random() * 3 + 2, color: '#ffffff', life: 1.0, decay: Math.random() * 0.05 + 0.03 }); }
            if (!isGameOver && !isClear) shakeAmount = 15; 
            if (player.jingi > 0 && !isClear) player.jingi--;
        }
        function createTrail(x, y, type) { if (obstacleTrails.length > 300) return; obstacleTrails.push({ x: x, y: y, alpha: 0.6, size: Math.random() * 4, color: (type === 'SPEAR') ? '#ffffff' : '#aaccff', speedX: Math.random() * 2, life: 1.0 }); }
        
        function spawnObstacle() {
            if (isClear) return;
            let progress = stageFrameCount / TOTAL_STAGE_TIME; 
            // â˜… ì •ìˆ˜ì˜ ì‚´ê¸° ìœ„í•œ í•˜í–¥ ì¡°ì • ë°˜ì˜!
            let currentSpawnProb = 0.035 + (0.055 * progress);
            if (Math.random() < currentSpawnProb) {
                const types = ['AXE', 'SPEAR', 'SWORD']; const selectedType = types[Math.floor(Math.random() * types.length)];
                let obsData = { x: canvas.width, angle: 0, isDeflected: false, vx: 0, vy: 0, type: selectedType, rotationSpeed: 0.18, size: 70 };
                switch(selectedType) {
                    case 'AXE': obsData.size = 60; obsData.speed = 7 + Math.random() * 3; obsData.y = canvas.height - TRAP_HEIGHT - 400; obsData.vy = -6 - Math.random() * 3; obsData.img = imgs.axe; break;
                    case 'SPEAR': obsData.size = 90; obsData.speed = 12 + Math.random() * 4; obsData.y = Math.random() * (canvas.height - TRAP_HEIGHT - 150); obsData.img = imgs.spear; break;
                    case 'SWORD': obsData.size = 70; obsData.speed = 10 + Math.random() * 3; obsData.y = player.y + (player.drawHeight / 2) - 35; obsData.img = imgs.sword; break;
                } obstacles.push(obsData);
            }
        }

        // ì…ë ¥ ì²˜ë¦¬ (í„°ì¹˜ ë° ë§ˆìš°ìŠ¤ ëª¨ë‘ ì§€ì›)
        function handlePointerDown(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            // â˜… ì¤‘ìš”: ìŠ¤ì¼€ì¼ëœ canvas ì¢Œí‘œë¥¼ ì‹¤ì œ canvas ì¢Œí‘œë¡œ ë³€í™˜
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (clientX - rect.left) * scaleX;
            const my = (clientY - rect.top) * scaleY;
            
            const cX = canvas.width/2;
            const cY = canvas.height/2;
            
            if (isGameOver) { if (mx >= cX - 100 && mx <= cX + 100 && my >= cY + 80 && my <= cY + 140) initGame(); return; }
            if (isPaused) {
                if (mx >= ui.soundIcon.x && mx <= ui.soundIcon.x + ui.soundIcon.size && my >= ui.soundIcon.y && my <= ui.soundIcon.y + ui.soundIcon.size) { if (volumeSteps > 0) { volumeSteps = 0; bgm.pause(); } else { volumeSteps = 4; bgm.volume = volumeSteps / 8; bgm.play().catch(() => {}); } gameOverSfx.volume = bgm.volume; return; }
                if (mx >= ui.volBar.x && mx <= ui.volBar.x + ui.volBar.w && my >= ui.volBar.y && my <= ui.volBar.y + ui.volBar.h) { volumeSteps = Math.ceil((mx - ui.volBar.x) / (ui.volBar.w / 8)); bgm.volume = volumeSteps / 8; gameOverSfx.volume = bgm.volume; if (volumeSteps > 0) bgm.play().catch(() => {}); else bgm.pause(); return; }
                if (mx >= cX - 100 && mx <= cX + 100 && my >= cY + 80 && my <= cY + 140) { isPaused = false; return; } return;
            }
            if (mx >= ui.optBtn.x && mx <= ui.optBtn.x + ui.optBtn.w && my >= ui.optBtn.y && my <= ui.optBtn.y + ui.optBtn.h) { isPaused = true; player.isPressing = false; return; }
            if (!isGameOver && !isClear && player.ceilingStunTimer <= 0) { player.isPressing = true; if(volumeSteps > 0) bgm.play().catch(() => {}); }
        }
        
        function handlePointerUp() {
            player.isPressing = false;
        }
        
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handlePointerDown(e);
        });
        
        window.addEventListener('mouseup', handlePointerUp);
        window.addEventListener('touchend', (e) => {
            e.preventDefault();
            handlePointerUp();
        });
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !isGameOver && !isClear) isPaused = !isPaused; });

        function update(deltaTime = 1) {
            if (!gameStarted) return; // ê²Œì„ ì‹œì‘ ì „ì—ëŠ” ì—…ë°ì´íŠ¸ ì•ˆ í•¨
            if (isPaused) return;
            if (player.jingi <= 0 && !isGameOver) {
                isGameOver = true; shakeAmount = 0; bgm.pause(); gameOverSfx.play();
                player.state = 'DEAD'; player.currentFrame = 0;
            }
            if (isGameOver) {
                const deadStopY = canvas.height - (TRAP_HEIGHT / 2) - (player.drawHeight / 2);
                if (player.y < deadStopY) { player.vy += 0.5 * deltaTime; player.y += player.vy * deltaTime; } else { player.y = deadStopY; player.vy = 0; }
                player.tickCount += deltaTime; if (player.tickCount > player.ticksPerFrame) { player.tickCount = 0; if (player.currentFrame < player.frames.DEAD - 1) player.currentFrame++; }
                return;
            }
            if (isClear) {
                if (!isFullyExited) {
                    player.state = 'CLEAR_EXIT'; player.x += 12 * deltaTime;
                    if (player.x > canvas.width) {
                        isFullyExited = true;
                        localStorage.setItem('maxJingi', player.maxJingi);
                        localStorage.setItem('jingiRecoverThreshold', savedRecoverThreshold);
                        setTimeout(() => { window.location.href = 'ending.html'; }, 2000);
                    }
                }
                return; 
            }
            stageFrameCount += deltaTime;
            if (stageFrameCount >= TOTAL_STAGE_TIME) { isClear = true; bgm.pause(); }

            if (player.jingi < player.maxJingi) { 
                player.jingiRecoverTick += deltaTime; 
                if (player.jingiRecoverTick >= savedRecoverThreshold) { player.jingi++; player.jingiRecoverTick = 0; } 
            }

            background.wallX -= background.wallSpeed * deltaTime; if (background.wallX <= -2560) background.wallX = 0;
            background.ceilingX -= background.ceilingSpeed * deltaTime; if (background.ceilingX <= -2560) background.ceilingX = 0;
            background.trapX -= 6 * deltaTime; if (background.trapX <= -canvas.width) background.trapX = 0;
            if (player.ceilingStunTimer > 0) { player.ceilingStunTimer -= deltaTime; player.isPressing = false; }
            if (player.isPressing) player.vy += player.thrust * deltaTime; player.vy += player.gravity * deltaTime; player.y += player.vy * deltaTime;
            if (player.y < 40) { if (player.ceilingStunTimer <= 0) createEnvBurst(player.x + player.drawWidth / 2, 40, true); player.y = 40; player.vy = 0.5; player.ceilingStunTimer = 10; }
            const trapLimit = canvas.height - TRAP_HEIGHT;
            if (player.y + player.drawHeight > trapLimit && player.vy >= 0) { createEnvBurst(player.x + player.drawWidth / 2, trapLimit, false); player.vy = -10; player.state = 'RISING'; player.currentFrame = 0; player.tickCount = 0; player.animDir = 1; createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight); }
            spawnObstacle();
            
            const phX = player.x + player.hitboxOffsetX; const phY = player.y + player.hitboxOffsetY;
            // â˜… ì¥ì• ë¬¼ ì¶©ëŒ ë¡œì§ ìˆ˜ì„  (ì¤‘ê´„í˜¸ ì •ë ¬ ì™„ë£Œ)
            obstacles.forEach((obs) => {
                if (!obs.isDeflected) {
                    obs.x -= obs.speed * deltaTime; 
                    // â˜… ë„ë¼ ì¤‘ë ¥ 0.11 ì ìš©
                    if (obs.type === 'AXE') { obs.y += obs.vy * deltaTime; obs.vy += 0.11 * deltaTime; obs.angle -= 0.18 * deltaTime; }
                    if (obs.type === 'SPEAR' || obs.type === 'SWORD') { createTrail(obs.x + 10, obs.y + obs.size/2, obs.type); }
                    
                    const oCX = obs.x + obs.size / 2; const oCY = obs.y + obs.size / 2;
                    const isHit = (phX < oCX + 20 && phX + 50 > oCX - 20 && phY < oCY + 20 && phY + 90 > oCY - 20);
                    
                    if (isHit) {
                        if (player.state !== 'DEFLECT') {
                            // --- ì²« ë²ˆì§¸ ë°˜ê²© ì„±ê³µ ---
                            if (player.jingi > 0) player.jingi--;
                            obs.isDeflected = true;
                            obs.vx = 10 + Math.random() * 5;
                            obs.vy = -15 - Math.random() * 5;
                            obs.rotationSpeed = (Math.random() > 0.5 ? 1 : -1) * 0.4;
                            createHitEffect(oCX, oCY);
                            player.state = 'DEFLECT';
                            player.currentFrame = 0;
                            player.tickCount = 0;
                        } else { 
                            // --- ë°˜ê²© ë™ì‘ ì¤‘ ì¶”ê°€ í”¼ê²© (ì •ìˆ˜ì˜ ìš”ì²­!) ---
                            if (player.jingi > 0) {
                                player.jingi--; 
                                createEnvBurst(oCX, oCY, false); 
                                obs.isDeflected = true; 
                                obs.vx = 5 + Math.random() * 5;
                                obs.vy = 5 + Math.random() * 5; 
                                obs.rotationSpeed = (Math.random() > 0.5 ? 1 : -1) * 0.4;
                            }
                        }
                    }
                } else { 
                    // [2] ì´ë¯¸ íŠ•ê²¨ë‚˜ê°„ ë¬´ê¸°ë“¤ì˜ ì´ë™ ë¡œì§
                    obs.x += obs.vx; obs.y += obs.vy; obs.vy += 0.8; obs.angle += obs.rotationSpeed; 
                }
            });

            if (shakeAmount > 0) shakeAmount -= 0.8 * deltaTime;
            for (let i = envParticles.length - 1; i >= 0; i--) { let p = envParticles[i]; p.x += p.vx * deltaTime; p.y += p.vy * deltaTime; p.life -= p.decay * deltaTime; if (p.life <= 0) envParticles.splice(i, 1); }
            for (let i = obstacleTrails.length - 1; i >= 0; i--) { let p = obstacleTrails[i]; p.x += p.speedX * deltaTime; p.life -= 0.15 * deltaTime; if (p.life <= 0) obstacleTrails.splice(i, 1); }
            for (let i = obstacles.length - 1; i >= 0; i--) { const o = obstacles[i]; if (o.x < -150 || o.x > canvas.width + 150 || o.y > canvas.height + 150) { obstacles.splice(i, 1); } }

            if (player.state !== 'DEFLECT' && player.state !== 'CLEAR_EXIT' && player.state !== 'DEAD') { 
                let newState = (player.vy < 0) ? 'RISING' : 'FALLING'; 
                if (player.state !== newState) { if (newState === 'RISING') createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight); player.state = newState; player.currentFrame = 0; player.tickCount = 0; player.animDir = 1; } 
            }

            // ì• ë‹ˆë©”ì´ì…˜ ë¡œì§ (ìƒìŠ¹ ê³ ì • & ì ë©¸ ë°©ì§€)
            player.tickCount += deltaTime;
            const total = player.frames[player.state] || 6; 
            if (player.tickCount > player.ticksPerFrame) {
                player.tickCount = 0;
                if (player.state === 'FALLING') { 
                    player.currentFrame += player.animDir; 
                    if (player.currentFrame >= total - 1 || player.currentFrame <= 0) player.animDir *= -1; 
                    player.currentFrame = Math.max(0, Math.min(total - 1, player.currentFrame)); 
                } else if (player.state === 'RISING') {
                    if (player.currentFrame < total - 1) player.currentFrame++;
                } else { 
                    player.currentFrame++; 
                    if (player.currentFrame >= total) { 
                        if (player.state === 'DEFLECT') player.state = (player.vy < 0) ? 'RISING' : 'FALLING'; 
                        player.currentFrame = 0; 
                    } 
                }
            }
            [jumpEffects, hitEffects].forEach(arr => { for (let i = arr.length - 1; i >= 0; i--) { let eff = arr[i]; eff.tickCount += deltaTime; if (eff.tickCount > eff.ticksPerFrame) { eff.tickCount = 0; eff.currentFrame++; if (eff.currentFrame >= eff.totalFrames) arr.splice(i, 1); } } });
        }

        function gameLoop(currentTime) {
            // ì²« í”„ë ˆì„ì´ê±°ë‚˜ currentTimeì´ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
            if (!currentTime || currentTime - lastTime > 1000) {
                lastTime = currentTime || performance.now();
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // deltaTime ê³„ì‚° (ë°€ë¦¬ì´ˆë¥¼ í”„ë ˆì„ ë°°ìœ¨ë¡œ ë³€í™˜)
            const deltaTime = (currentTime - lastTime) / FRAME_TIME;
            lastTime = currentTime;
            
            // deltaTimeì´ ë„ˆë¬´ í¬ë©´ ì œí•œ (íƒ­ ì „í™˜ ë“±ìœ¼ë¡œ ì¸í•œ í° ì í”„ ë°©ì§€)
            const clampedDelta = Math.min(deltaTime, 3);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            if (shakeAmount > 0) ctx.translate(Math.random() * shakeAmount - shakeAmount / 2, Math.random() * shakeAmount - shakeAmount / 2);
            if (imgs.wall.complete) { ctx.drawImage(imgs.wall, background.wallX, canvas.height - 850, 2560, 850); ctx.drawImage(imgs.wall, background.wallX + 2560, canvas.height - 850, 2560, 850); }
            obstacleTrails.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0;
            envParticles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); }); ctx.globalAlpha = 1.0;
            jumpEffects.forEach(eff => { if (imgs.jumpEff.complete) ctx.drawImage(imgs.jumpEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size); });
            if (player.state === 'CLEAR_EXIT') { if (imgs.rightOut.complete) ctx.drawImage(imgs.rightOut, player.x, player.y, player.drawWidth, player.drawHeight); }
            else { let curS = imgs[player.state.toLowerCase()]; if (curS && curS.complete) ctx.drawImage(curS, player.currentFrame * 256, 0, 256, 256, player.x, player.y, player.drawWidth, player.drawHeight); }
            obstacles.forEach(obs => { ctx.save(); ctx.translate(obs.x + obs.size/2, obs.y + obs.size/2); if (obs.type === 'AXE' || obs.isDeflected) ctx.rotate(obs.angle); if (obs.img.complete) ctx.drawImage(obs.img, -obs.size/2, -obs.size/2, obs.size, obs.size); ctx.restore(); });
            hitEffects.forEach(eff => { if (imgs.hitEff.complete) ctx.drawImage(imgs.hitEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size); });
            if (imgs.trap.complete) { ctx.drawImage(imgs.trap, background.trapX, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT); ctx.drawImage(imgs.trap, background.trapX + canvas.width, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT); }
            if (imgs.ceiling.complete) { ctx.drawImage(imgs.ceiling, background.ceilingX, 0, 2560, 80); ctx.drawImage(imgs.ceiling, background.ceilingX + 2560, 0, 2560, 80); }
            ctx.restore();

            // UI í…Œë‘ë¦¬ êµµê¸° ì´ˆê¸°í™”
            const jb = ui.jingiBar;
            ctx.lineWidth = 2; 
            for (let i = 0; i < player.maxJingi; i++) {
                ctx.fillStyle = (i < player.jingi) ? jb.color : 'rgba(255, 255, 255, 0.1)';
                ctx.strokeStyle = (i < player.jingi) ? 'white' : 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(jb.x + i * (jb.segW + jb.gap), jb.y, jb.segW, jb.segH); ctx.strokeRect(jb.x + i * (jb.segW + jb.gap), jb.y, jb.segW, jb.segH);
            }
            const barW = (jb.segW * player.maxJingi + jb.gap * (player.maxJingi - 1));
            ctx.fillStyle = 'orange'; ctx.fillRect(jb.x, jb.y + jb.segH + 12, barW * (stageFrameCount / TOTAL_STAGE_TIME), 6);
            if (imgs.optionBtn.complete) ctx.drawImage(imgs.optionBtn, ui.optBtn.x, ui.optBtn.y, ui.optBtn.w, ui.optBtn.h);

            if (isGameOver) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white'; ctx.font = '110px "Dokdo"'; ctx.textAlign = 'center'; ctx.fillText('ë‚œê´€ ëŒíŒŒ ì‹¤íŒ¨', canvas.width/2, canvas.height/2 - 20);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(canvas.width/2 - 100, canvas.height/2 + 80, 200, 60);
                ctx.fillStyle = 'white'; ctx.font = '40px "Dokdo"'; ctx.textBaseline = 'middle'; ctx.fillText('ì¬ë„ì „', canvas.width/2, canvas.height/2 + 112); ctx.textBaseline = 'alphabetic';
            }
            if (isClear && isFullyExited) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white'; ctx.font = '110px "Dokdo"'; ctx.textAlign = 'center'; ctx.fillText('ë§ˆì§€ë§‰ ë‚œê´€ ëŒíŒŒ!', canvas.width/2, canvas.height/2);
            }
            if (isPaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cX = canvas.width/2; const cY = canvas.height/2;
                ctx.fillStyle = '#2d1b0d'; ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 8;
                ctx.strokeRect(cX - 300, cY - 200, 600, 400); ctx.fillRect(cX - 300, cY - 200, 600, 400);
                const sImg = (volumeSteps === 0) ? imgs.bgmOff : imgs.bgmOn;
                if (sImg.complete) ctx.drawImage(sImg, ui.soundIcon.x, ui.soundIcon.y, ui.soundIcon.size, ui.soundIcon.size);
                const vStepW = (ui.volBar.w / 8) - ui.volBar.gap;
                for (let i = 0; i < 8; i++) { ctx.fillStyle = (i < volumeSteps) ? '#f1c40f' : '#1a1008'; ctx.fillRect(ui.volBar.x + i * (vStepW + ui.volBar.gap), ui.volBar.y, vStepW, ui.volBar.h); }
                ctx.fillStyle = '#5d4037'; ctx.fillRect(cX - 100, cY + 80, 200, 60);
                ctx.fillStyle = 'white'; ctx.font = '40px "Dokdo"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ë„ì „ ì§€ì†', cX, cY + 112); ctx.textBaseline = 'alphabetic';
            }
            update(clampedDelta); 
            requestAnimationFrame(gameLoop);
        }
        gameLoop();
        
        // ===== PWA í™”ë©´ ë°©í–¥ ì œì–´ =====
        async function lockOrientation() {
            try {
                if (screen.orientation && screen.orientation.lock) {
                    await screen.orientation.lock('landscape');
                }
            } catch (error) {
                console.warn('[PWA] í™”ë©´ ë°©í–¥ ê³ ì • ì‹¤íŒ¨:', error);
            }
        }
        
        lockOrientation();
        
        const rotateOverlay = document.getElementById('rotateOverlay');
        function checkOrientation() {
            const isPortrait = window.innerHeight > window.innerWidth;
            rotateOverlay.style.display = isPortrait ? 'flex' : 'none';
        }
        
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', () => {
            checkOrientation();
            lockOrientation();
        });
        checkOrientation();
        
        // ===== í•˜ë“œì›¨ì–´ ë’¤ë¡œê°€ê¸° ë²„íŠ¼ ê°ì§€ ë° ë°©ì§€ =====
        
        const backConfirmOverlay = document.getElementById('backConfirmOverlay');
        const continueBtn = document.getElementById('continueBtn');
        const exitBtn = document.getElementById('exitBtn');
        let isBackConfirmShowing = false;
        let wasPausedBeforeBack = false;
        
        history.pushState({ page: 'game' }, '', location.href);
        
        window.addEventListener('popstate', (event) => {
            if (!isBackConfirmShowing) {
                history.pushState({ page: 'game' }, '', location.href);
                wasPausedBeforeBack = isPaused;
                if (!isPaused) {
                    isPaused = true;
                }
                isBackConfirmShowing = true;
                backConfirmOverlay.classList.add('show');
            }
        });
        
        function handleContinue() {
            backConfirmOverlay.classList.remove('show');
            isBackConfirmShowing = false;
            if (!wasPausedBeforeBack) {
                isPaused = false;
            }
        }
        
        continueBtn.addEventListener('click', handleContinue);
        continueBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleContinue();
        });
        
        function handleExit() {
            backConfirmOverlay.classList.remove('show');
            isBackConfirmShowing = false;
            history.go(-1);
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 10);
        }
        
        exitBtn.addEventListener('click', handleExit);
        exitBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleExit();
        });
    </script>
</body>
</html>