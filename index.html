<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정수협객: 도검 산림 (완성형)</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background: #0a0a0a; border: 5px solid #5d4037; box-shadow: 0 0 20px rgba(0,255,0,0.2); }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600;
        canvas.height = 900;

        // 1. 에셋 로딩 (총 12종)
        const imgs = {
            rising: new Image(), falling: new Image(), jumpEff: new Image(),
            bgFar: new Image(), bgNear: new Image(), trap: new Image(),
            deflect: new Image(), axe: new Image(), spear: new Image(), sword: new Image(),
            hitEff: new Image()
        };

        imgs.rising.src = 'assets/rising_sheet.png';
        imgs.falling.src = 'assets/falling_sheet.png';
        imgs.jumpEff.src = 'assets/jump_effect_sheet.png'; 
        imgs.bgFar.src = 'assets/bg_far.png';
        imgs.bgNear.src = 'assets/bg_near.png';
        imgs.axe.src = 'assets/axe.png'; 
        imgs.spear.src = 'assets/spear.png'; 
        imgs.sword.src = 'assets/sword.png'; 
        imgs.trap.src = 'assets/trap_asset.png'; 
        imgs.deflect.src = 'assets/deflect_sheet.png'; 
        imgs.hitEff.src = 'assets/hit_effect_sheet.png';

        // 2. 환경 및 물리 수치
        const DEBUG_MODE = true; 
        const TRAP_HEIGHT = 80;
        const TRAP_SPEED = 6;
        const OBSTACLE_GRAVITY = 0.8; 
        const AXE_GRAVITY = 0.09; // 정수's 픽!

        const player = {
            x: 350, y: 100, drawWidth: 125, drawHeight: 125,
            hitboxWidth: 50, hitboxHeight: 90, hitboxOffsetX: 25, hitboxOffsetY: 15, //
            vy: 0, gravity: 0.4, thrust: -1.2, isPressing: false,
            state: 'FALLING', currentFrame: 0, tickCount: 0, ticksPerFrame: 5,
            animDir: 1, // 핑퐁 애니메이션용 방향
            frames: { RISING: 6, FALLING: 6, DEFLECT: 3 } // 정수's 픽!
        };

        let jumpEffects = []; let hitEffects = []; let obstacles = [];
        const background = { farX: 0, farSpeed: 1, nearX: 0, nearSpeed: 4, trapX: 0 };

        // 3. 효과 생성 함수
        function createJumpEffect(px, py, pw, ph) {
            const effSize = 130; 
            jumpEffects.push({ x: px + (pw / 2) - (effSize / 2) - 15, y: py + ph - (effSize / 2) - 19, size: effSize, currentFrame: 0, totalFrames: 6, tickCount: 0, ticksPerFrame: 3 });
        }

        function createHitEffect(x, y) {
            // 정수's 픽: X:0, Y:-75 위치 보정
            hitEffects.push({ x: x, y: y - 50, size: 100, currentFrame: 0, totalFrames: 5, tickCount: 0, ticksPerFrame: 2 });
        }

        function deflectObstacle(obs) {
            if (obs.isDeflected) return;
            obs.isDeflected = true;
            obs.vx = 10 + Math.random() * 5;
            obs.vy = -15 - Math.random() * 5;
            obs.rotationSpeed = (Math.random() > 0.5 ? 1 : -1) * (0.6 + Math.random() * 0.4);
        }

        function spawnObstacle() {
            if (Math.random() < 0.018) {
                const types = ['AXE', 'SPEAR', 'SWORD'];
                const selectedType = types[Math.floor(Math.random() * types.length)];
                let obsData = { x: canvas.width, isColliding: false, angle: 0, isDeflected: false, vx: 0, vy: 0, type: selectedType };
                
                switch(selectedType) {
                    case 'AXE':
                        obsData.size = 60; obsData.speed = 6 + Math.random() * 3;
                        obsData.y = canvas.height - TRAP_HEIGHT - 400; //
                        obsData.vy = -6 - Math.random() * 3; //
                        obsData.rotationSpeed = 0.18;
                        obsData.hitboxW = 40; obsData.hitboxH = 40; obsData.img = imgs.axe; break;
                    case 'SPEAR':
                        obsData.size = 90; obsData.speed = 12 + Math.random() * 3; obsData.y = Math.random() * (canvas.height - TRAP_HEIGHT - 150);
                        obsData.rotationSpeed = 0; obsData.hitboxW = 70; obsData.hitboxH = 10; obsData.img = imgs.spear; break;
                    case 'SWORD':
                        obsData.size = 70; obsData.speed = 9 + Math.random() * 3; obsData.y = Math.random() * (canvas.height - TRAP_HEIGHT - 150);
                        obsData.rotationSpeed = 0; obsData.hitboxW = 50; obsData.hitboxH = 15; obsData.img = imgs.sword; break;
                }
                obstacles.push(obsData);
            }
        }

        // 4. 입력 핸들러
        window.addEventListener('mousedown', () => { player.isPressing = true; });
        window.addEventListener('mouseup', () => { player.isPressing = false; });

        // 5. 게임 로직 업데이트
        function update() {
            background.farX -= background.farSpeed; if (background.farX <= -canvas.width) background.farX = 0;
            background.nearX -= background.nearSpeed; if (background.nearX <= -canvas.width) background.nearX = 0;
            background.trapX -= TRAP_SPEED; if (background.trapX <= -canvas.width) background.trapX = 0;

            if (player.isPressing) player.vy += player.thrust; player.vy += player.gravity; player.y += player.vy;
            if (player.y < 0) { player.y = 0; player.vy = 0; }

            // 함정 자동 방어 (Auto-Jump)
            if (player.y + player.drawHeight > canvas.height - TRAP_HEIGHT && player.vy >= 0) {
                player.vy = -10; // 정수's 픽!
                player.state = 'RISING'; player.currentFrame = 0; player.tickCount = 0; player.animDir = 1;
                createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight);
            }

            spawnObstacle();
            const phX = player.x + player.hitboxOffsetX; const phY = player.y + player.hitboxOffsetY;

            obstacles.forEach((obs) => {
                if (!obs.isDeflected) {
                    obs.x -= obs.speed;
                    if (obs.type === 'AXE') { obs.y += obs.vy; obs.vy += AXE_GRAVITY; obs.angle -= obs.rotationSpeed; }
                    const oCX = obs.x + obs.size / 2; const oCY = obs.y + obs.size / 2;
                    const isHit = (phX < oCX + obs.hitboxW/2 && phX + player.hitboxWidth > oCX - obs.hitboxW/2 && phY < oCY + obs.hitboxH/2 && phY + player.hitboxHeight > oCY - obs.hitboxH/2);
                    
                    // 쳐내기 중복 실행 방지 (애니메이션 멈춤 버그 수정)
                    if (isHit && player.state !== 'DEFLECT') { 
                        deflectObstacle(obs); createHitEffect(oCX, oCY); 
                        player.state = 'DEFLECT'; player.currentFrame = 0; player.tickCount = 0; 
                    }
                } else {
                    obs.x += obs.vx; obs.y += obs.vy; obs.vy += OBSTACLE_GRAVITY; obs.angle += obs.rotationSpeed;
                }
            });

            // 플레이어 애니메이션 안정화 로직 (점멸 버그 수정)
            if (player.state !== 'DEFLECT') {
                let newState = (player.vy < 0) ? 'RISING' : 'FALLING';
                if (player.state !== newState) {
                    if (newState === 'RISING') createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight);
                    player.state = newState; player.currentFrame = 0; player.tickCount = 0; player.animDir = 1; // 방향 초기화
                }
            }

            player.tickCount++; 
            const charTotalFrames = player.frames[player.state];

            if (player.tickCount > player.ticksPerFrame) {
                player.tickCount = 0;
                if (player.state === 'DEFLECT') { 
                    player.currentFrame++; 
                    if (player.currentFrame >= charTotalFrames) { 
                        player.state = (player.vy < 0) ? 'RISING' : 'FALLING'; 
                        player.currentFrame = 0; player.animDir = 1; // 복귀 시 방향 초기화
                    } 
                } 
                else if (player.state === 'FALLING') { 
                    // 하강 핑퐁 루프 안전장치
                    player.currentFrame += player.animDir; 
                    if (player.currentFrame >= charTotalFrames - 1) { player.currentFrame = charTotalFrames - 1; player.animDir = -1; }
                    else if (player.currentFrame <= 0) { player.currentFrame = 0; player.animDir = 1; }
                }
                else if (player.state === 'RISING') {
                    if (player.currentFrame < charTotalFrames - 1) player.currentFrame++;
                }
            }

            // 이펙트 업데이트
            [jumpEffects, hitEffects].forEach(arr => { for (let i = arr.length - 1; i >= 0; i--) { let eff = arr[i]; eff.tickCount++; if (eff.tickCount > eff.ticksPerFrame) { eff.tickCount = 0; eff.currentFrame++; if (eff.currentFrame >= eff.totalFrames) arr.splice(i, 1); } } });
            for (let i = obstacles.length - 1; i >= 0; i--) { if (obstacles[i].x < -200 || obstacles[i].x > canvas.width + 200 || obstacles[i].y > canvas.height + 200) obstacles.splice(i, 1); }
        }

        // 6. 렌더링
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (imgs.bgFar.complete) { ctx.drawImage(imgs.bgFar, background.farX, 0, canvas.width, canvas.height); ctx.drawImage(imgs.bgFar, background.farX + canvas.width, 0, canvas.width, canvas.height); }
            if (imgs.bgNear.complete) { ctx.drawImage(imgs.bgNear, background.nearX, 0, canvas.width, canvas.height); ctx.drawImage(imgs.bgNear, background.nearX + canvas.width, 0, canvas.width, canvas.height); }
            
            jumpEffects.forEach(eff => { if (imgs.jumpEff.complete) ctx.drawImage(imgs.jumpEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size); });
            
            let curS = (player.state === 'DEFLECT') ? imgs.deflect : (player.state === 'RISING' ? imgs.rising : imgs.falling);
            if (curS.complete) ctx.drawImage(curS, player.currentFrame * 256, 0, 256, 256, player.x, player.y, player.drawWidth, player.drawHeight);
            
            obstacles.forEach(obs => {
                ctx.save(); ctx.translate(obs.x + obs.size/2, obs.y + obs.size/2);
                if (obs.type === 'AXE' || obs.isDeflected) ctx.rotate(obs.angle);
                if (obs.img.complete) ctx.drawImage(obs.img, -obs.size/2, -obs.size/2, obs.size, obs.size);
                ctx.restore();
            });
            
            hitEffects.forEach(eff => { if (imgs.hitEff.complete) ctx.drawImage(imgs.hitEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size); });
            
            if (imgs.trap.complete) { ctx.drawImage(imgs.trap, background.trapX, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT); ctx.drawImage(imgs.trap, background.trapX + canvas.width, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT); }
            
            if (DEBUG_MODE) {
                ctx.strokeStyle = player.state === 'DEFLECT' ? "orange" : "yellow";
                ctx.strokeRect(player.x + player.hitboxOffsetX, player.y + player.hitboxOffsetY, player.hitboxWidth, player.hitboxHeight);
            }
            
            update(); requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>