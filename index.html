<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정수협객: 도검 산림 (긴급 복구 완료)</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background: #0a0a0a; border: 5px solid #5d4037; box-shadow: 0 0 20px rgba(0,255,0,0.2); }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600;
        canvas.height = 900;

        // 1. 에셋 로딩 (오타 방지를 위해 주소 재확인 필수!)
        const imgs = {
            rising: new Image(),
            falling: new Image(),
            jumpEff: new Image(),
            bgFar: new Image(),
            bgNear: new Image(),
            obs: new Image(),
            trap: new Image() 
        };

        // ★ [주의] 파일명이 실제 폴더의 이름과 정확히 일치해야 해!
        imgs.rising.src = 'assets/rising_sheet.png';
        imgs.falling.src = 'assets/falling_sheet.png';
        imgs.jumpEff.src = 'assets/jump_effect_sheet.png'; 
        imgs.bgFar.src = 'assets/bg_far.png';
        imgs.bgNear.src = 'assets/bg_near.png';
        imgs.obs.src = 'assets/projectile.png';
        imgs.trap.src = 'assets/trap_asset.png'; 

        const DEBUG_MODE = true; 
        const TRAP_HEIGHT = 80; 
        const TRAP_SPEED = 6; 

        // 2. 플레이어 설정
        const player = {
            x: 350, y: 100,
            drawWidth: 125, drawHeight: 125,
            hitboxWidth: 50, hitboxHeight: 90,
            hitboxOffsetX: 25, hitboxOffsetY: 15,
            vy: 0, gravity: 0.4, thrust: -1.2, isPressing: false,
            state: 'FALLING', currentFrame: 0, totalFrames: 6,
            frameWidth: 256, frameHeight: 256,
            tickCount: 0, ticksPerFrame: 5, animDir: 1
        };

        let jumpEffects = [];
        let obstacles = [];
        const background = { farX: 0, farSpeed: 1, nearX: 0, nearSpeed: 4, trapX: 0 };

        function createJumpEffect(px, py, pw, ph) {
            const effSize = 130; 
            jumpEffects.push({
                x: px + (pw / 2) - (effSize / 2) - 15, 
                y: py + ph - (effSize / 2) - 19, 
                size: effSize, currentFrame: 0, totalFrames: 6, tickCount: 0, ticksPerFrame: 3
            });
        }

        function spawnObstacle() {
            if (Math.random() < 0.015) { // 확률 살짝 낮춤
                obstacles.push({
                    x: canvas.width, 
                    y: Math.random() * (canvas.height - TRAP_HEIGHT - 150),
                    size: 50, speed: 7 + Math.random() * 5, isColliding: false
                });
            }
        }

        // 입력 이벤트
        window.addEventListener('mousedown', () => { player.isPressing = true; });
        window.addEventListener('mouseup', () => { player.isPressing = false; });
        // 스마트폰 터치 대응
        window.addEventListener('touchstart', (e) => { e.preventDefault(); player.isPressing = true; }, {passive: false});
        window.addEventListener('touchend', () => { player.isPressing = false; });

        function update() {
            // 배경/함정 스크롤
            background.farX -= background.farSpeed; if (background.farX <= -canvas.width) background.farX = 0;
            background.nearX -= background.nearSpeed; if (background.nearX <= -canvas.width) background.nearX = 0;
            background.trapX -= TRAP_SPEED; if (background.trapX <= -canvas.width) background.trapX = 0;

            // 중력 및 추력
            if (player.isPressing) player.vy += player.thrust;
            player.vy += player.gravity;
            player.y += player.vy;

            // 경계 제한
            if (player.y < 0) { player.y = 0; player.vy = 0; }
            const floorLimit = canvas.height - player.drawHeight;
            if (player.y > floorLimit) { player.y = floorLimit; player.vy = 0; }

            // 상태 결정 및 이펙트
            let newState = (player.vy < 0) ? 'RISING' : 'FALLING';
            if (player.state !== newState) {
                if (newState === 'RISING') createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight);
                player.state = newState;
                player.currentFrame = 0;
                player.tickCount = 0;
                player.animDir = 1;
            }

            // 애니메이션
            player.tickCount++;
            if (player.tickCount > player.ticksPerFrame) {
                player.tickCount = 0;
                if (player.state === 'RISING') {
                    if (player.currentFrame < player.totalFrames - 1) player.currentFrame++;
                } else {
                    player.currentFrame += player.animDir;
                    if (player.currentFrame >= player.totalFrames - 1) { player.currentFrame = player.totalFrames - 1; player.animDir = -1; }
                    if (player.currentFrame <= 0) { player.currentFrame = 0; player.animDir = 1; }
                }
            }

            // 이펙트/장애물
            for (let i = jumpEffects.length - 1; i >= 0; i--) {
                let eff = jumpEffects[i];
                eff.tickCount++;
                if (eff.tickCount > eff.ticksPerFrame) {
                    eff.tickCount = 0; eff.currentFrame++;
                    if (eff.currentFrame >= eff.totalFrames) jumpEffects.splice(i, 1);
                }
            }

            spawnObstacle();
            const phX = player.x + player.hitboxOffsetX;
            const phY = player.y + player.hitboxOffsetY;
            obstacles.forEach((obs, i) => {
                obs.x -= obs.speed;
                if (phX < obs.x + obs.size && phX + player.hitboxWidth > obs.x &&
                    phY < obs.y + obs.size && phY + player.hitboxHeight > obs.y) {
                    obs.isColliding = true;
                } else { obs.isColliding = false; }
                if (obs.x + obs.size < 0) obstacles.splice(i, 1);
            });
        }

        function draw() {
            // 1. 화면 클리어
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. 배경 (이미지 로딩 체크)
            if (imgs.bgFar.complete) {
                ctx.drawImage(imgs.bgFar, background.farX, 0, canvas.width, canvas.height);
                ctx.drawImage(imgs.bgFar, background.farX + canvas.width, 0, canvas.width, canvas.height);
            }
            if (imgs.bgNear.complete) {
                ctx.drawImage(imgs.bgNear, background.nearX, 0, canvas.width, canvas.height);
                ctx.drawImage(imgs.bgNear, background.nearX + canvas.width, 0, canvas.width, canvas.height);
            }

            // 3. 점프 이펙트
            jumpEffects.forEach(eff => {
                if (imgs.jumpEff.complete) {
                    ctx.drawImage(imgs.jumpEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size);
                }
            });

            // 4. 캐릭터
            let currentSheet = (player.state === 'RISING') ? imgs.rising : imgs.falling;
            if (currentSheet.complete && currentSheet.width > 0) {
                ctx.drawImage(currentSheet, player.currentFrame * player.frameWidth, 0, player.frameWidth, player.frameHeight, player.x, player.y, player.drawWidth, player.drawHeight);
            } else {
                // 이미지 없을 때 임시 박스
                ctx.fillStyle = "white";
                ctx.fillRect(player.x, player.y, player.drawWidth, player.drawHeight);
            }

            // 5. 장애물
            obstacles.forEach(obs => {
                ctx.fillStyle = obs.isColliding ? "lime" : "red";
                ctx.fillRect(obs.x, obs.y, obs.size, obs.size);
            });

            // 6. 함정 (맨 위)
            if (imgs.trap.complete && imgs.trap.width > 0) {
                ctx.drawImage(imgs.trap, background.trapX, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT);
                ctx.drawImage(imgs.trap, background.trapX + canvas.width, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT);
            } else {
                ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
                ctx.fillRect(0, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT);
            }

            // 7. 디버그 및 상태 UI
            if (DEBUG_MODE) {
                ctx.strokeStyle = "yellow";
                ctx.strokeRect(player.x + player.hitboxOffsetX, player.y + player.hitboxOffsetY, player.hitboxWidth, player.hitboxHeight);
                ctx.fillStyle = "white";
                ctx.font = "20px Arial";
                ctx.fillText(`FPS: 60 | State: ${player.state} | Pos: ${Math.floor(player.y)}`, 20, 40);
            }

            update();
            requestAnimationFrame(draw);
        }

        // 모든 이미지가 로딩되지 않아도 일단 루프 시작!
        draw();
    </script>
</body>
</html>