<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정수협객: 애니메이션 정밀 제어</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background: #0a0a0a; border: 5px solid #5d4037; box-shadow: 0 0 20px rgba(0,255,0,0.2); }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600;
        canvas.height = 900;

        const imgs = {
            rising: new Image(), falling: new Image(), jumpEff: new Image(),
            bgFar: new Image(), bgNear: new Image(), obs: new Image(), trap: new Image(),
            shieldBody: new Image(), shieldEff: new Image()
        };

        imgs.rising.src = 'assets/rising_sheet.png';
        imgs.falling.src = 'assets/falling_sheet.png';
        imgs.jumpEff.src = 'assets/jump_effect_sheet.png'; 
        imgs.bgFar.src = 'assets/bg_far.png';
        imgs.bgNear.src = 'assets/bg_near.png';
        imgs.obs.src = 'assets/projectile.png';
        imgs.trap.src = 'assets/trap_asset.png'; 
        imgs.shieldBody.src = 'assets/shield_body_sheet.png';
        imgs.shieldEff.src = 'assets/shield_effect_sheet.png';

        const DEBUG_MODE = true; 
        const TRAP_HEIGHT = 80; 
        const TRAP_SPEED = 6; 

        // 2. 플레이어 및 애니메이션 설정
        const player = {
            x: 350, y: 100,
            drawWidth: 125, drawHeight: 125,
            hitboxWidth: 50, hitboxHeight: 90,
            hitboxOffsetX: 25, hitboxOffsetY: 15,
            vy: 0, gravity: 0.4, thrust: -1.2, isPressing: false,
            state: 'FALLING', 
            currentFrame: 0, tickCount: 0, ticksPerFrame: 5,
            animDir: 1, // ★ 하강 핑퐁을 위한 방향 변수

            // =========================================================
            // ★ [조정 포인트 1] 캐릭터 본체 상태별 프레임 수
            // =========================================================
            frames: {
                RISING: 6,   // 상승 동작 프레임
                FALLING: 6,  // 하강 동작 프레임
                SHIELD: 16    // 호신강기 시 캐릭터 본체 프레임 (나중에 10, 15로 수정 가능!)
            },

            // =========================================================
            // ★ [조정 포인트 2] 호신강기 이펙트 상세 설정
            // =========================================================
            shield: {
                currentFrame: 0,
                tickCount: 0,
                totalFrames: 16,      // [이펙트 프레임 수]
                ticksPerFrame: 5,    // [이펙트 재생 속도]
                size: 175,           // [이펙트 크기]
                offsetX: 10,      // [X 오프셋] 캐릭터 중앙 정렬용
                offsetY: -40       // [Y 오프셋] 캐릭터 중앙 정렬용
            }
        };

        let jumpEffects = [];
        let obstacles = [];
        const background = { farX: 0, farSpeed: 1, nearX: 0, nearSpeed: 4, trapX: 0 };

        function createJumpEffect(px, py, pw, ph) {
            const effSize = 130; 
            jumpEffects.push({
                x: px + (pw / 2) - (effSize / 2) - 15,
                y: py + ph - (effSize / 2) - 19,
                size: effSize, currentFrame: 0, totalFrames: 6, tickCount: 0, ticksPerFrame: 3
            });
        }

        window.addEventListener('mousedown', () => { player.isPressing = true; });
        window.addEventListener('mouseup', () => { player.isPressing = false; });
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && player.state !== 'SHIELD') {
                player.state = 'SHIELD';
                player.currentFrame = 0;
                player.tickCount = 0;
                player.shield.currentFrame = 0;
                player.shield.tickCount = 0;
            }
        });

        function update() {
            background.farX -= background.farSpeed; if (background.farX <= -canvas.width) background.farX = 0;
            background.nearX -= background.nearSpeed; if (background.nearX <= -canvas.width) background.nearX = 0;
            background.trapX -= TRAP_SPEED; if (background.trapX <= -canvas.width) background.trapX = 0;

            if (player.isPressing) player.vy += player.thrust;
            player.vy += player.gravity; player.y += player.vy;

            if (player.y < 0) { player.y = 0; player.vy = 0; }
            const floorLimit = canvas.height - player.drawHeight;
            if (player.y > floorLimit) { player.y = floorLimit; player.vy = 0; }

            // 상태 변화 감지 및 이펙트 트리거
            if (player.state !== 'SHIELD') {
                let newState = (player.vy < 0) ? 'RISING' : 'FALLING';
                if (player.state !== newState) {
                    if (newState === 'RISING') createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight);
                    player.state = newState;
                    player.currentFrame = 0;
                    player.tickCount = 0;
                    player.animDir = 1; // 상태 변화 시 방향 초기화
                }
            }

            // --- 캐릭터 애니메이션 업데이트 ---
            player.tickCount++;
            const charTotalFrames = player.frames[player.state]; // 현재 상태의 캐릭터 프레임 수

            if (player.tickCount > player.ticksPerFrame) {
                player.tickCount = 0;
                
                if (player.state === 'RISING') {
                    // 상승: 마지막 프레임 고정
                    if (player.currentFrame < charTotalFrames - 1) player.currentFrame++;
                } 
                else if (player.state === 'FALLING') {
                    // ★ [하강 핑퐁 루프] 적용 완료!
                    player.currentFrame += player.animDir;
                    if (player.currentFrame >= charTotalFrames - 1) {
                        player.currentFrame = charTotalFrames - 1;
                        player.animDir = -1; // 역방향 전환
                    } else if (player.currentFrame <= 0) {
                        player.currentFrame = 0;
                        player.animDir = 1; // 정방향 전환
                    }
                } 
                else if (player.state === 'SHIELD') {
                    // 호신강기 몸체: 이펙트와 별개로 자신의 프레임 수에 맞춰 재생
                    player.currentFrame = (player.currentFrame + 1) % charTotalFrames;
                }
            }

            // ★ 호신강기 이펙트 업데이트
            if (player.state === 'SHIELD') {
                player.shield.tickCount++;
                if (player.shield.tickCount > player.shield.ticksPerFrame) {
                    player.shield.tickCount = 0;
                    player.shield.currentFrame++;
                    
                    // 이펙트 재생이 끝나면 복귀
                    if (player.shield.currentFrame >= player.shield.totalFrames) {
                        player.state = (player.vy < 0) ? 'RISING' : 'FALLING';
                        player.currentFrame = 0;
                        player.animDir = 1;
                    }
                }
            }

            // (이펙트 및 장애물 업데이트 로직 유지)
            for (let i = jumpEffects.length - 1; i >= 0; i--) {
                let eff = jumpEffects[i]; eff.tickCount++;
                if (eff.tickCount > eff.ticksPerFrame) {
                    eff.tickCount = 0; eff.currentFrame++;
                    if (eff.currentFrame >= eff.totalFrames) jumpEffects.splice(i, 1);
                }
            }
            if (Math.random() < 0.015) {
                obstacles.push({ x: canvas.width, y: Math.random() * (canvas.height - TRAP_HEIGHT - 150), size: 50, speed: 7 + Math.random() * 5, isColliding: false });
            }
            const phX = player.x + player.hitboxOffsetX;
            const phY = player.y + player.hitboxOffsetY;
            obstacles.forEach((obs, i) => {
                obs.x -= obs.speed;
                if (player.state !== 'SHIELD') {
                    if (phX < obs.x + obs.size && phX + player.hitboxWidth > obs.x && phY < obs.y + obs.size && phY + player.hitboxHeight > obs.y) { obs.isColliding = true; }
                } else { obs.isColliding = false; }
                if (obs.x + obs.size < 0) obstacles.splice(i, 1);
            });
        }

        function draw() {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (imgs.bgFar.complete) {
                ctx.drawImage(imgs.bgFar, background.farX, 0, canvas.width, canvas.height);
                ctx.drawImage(imgs.bgFar, background.farX + canvas.width, 0, canvas.width, canvas.height);
            }
            if (imgs.bgNear.complete) {
                ctx.drawImage(imgs.bgNear, background.nearX, 0, canvas.width, canvas.height);
                ctx.drawImage(imgs.bgNear, background.nearX + canvas.width, 0, canvas.width, canvas.height);
            }

            jumpEffects.forEach(eff => {
                if (imgs.jumpEff.complete) ctx.drawImage(imgs.jumpEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size);
            });

            // 1. 캐릭터 본체 그리기
            let currentSheet = (player.state === 'SHIELD') ? imgs.shieldBody : (player.state === 'RISING' ? imgs.rising : imgs.falling);
            if (currentSheet.complete) {
                ctx.drawImage(currentSheet, player.currentFrame * 256, 0, 256, 256, player.x, player.y, player.drawWidth, player.drawHeight);
            }

            // 2. 호신강기 이펙트 그리기 (캐릭터 앞쪽)
            if (player.state === 'SHIELD' && imgs.shieldEff.complete) {
                ctx.drawImage(
                    imgs.shieldEff,
                    player.shield.currentFrame * 256, 0, 256, 256,
                    player.x + player.shield.offsetX,
                    player.y + player.shield.offsetY,
                    player.shield.size,
                    player.shield.size
                );
            }

            obstacles.forEach(obs => {
                ctx.fillStyle = obs.isColliding ? "lime" : "red";
                ctx.fillRect(obs.x, obs.y, obs.size, obs.size);
            });

            if (imgs.trap.complete) {
                ctx.drawImage(imgs.trap, background.trapX, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT);
                ctx.drawImage(imgs.trap, background.trapX + canvas.width, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT);
            }

            if (DEBUG_MODE) {
                ctx.strokeStyle = player.state === 'SHIELD' ? "cyan" : "yellow";
                ctx.strokeRect(player.x + player.hitboxOffsetX, player.y + player.hitboxOffsetY, player.hitboxWidth, player.hitboxHeight);
                ctx.fillStyle = "white"; ctx.font = "18px Arial";
                ctx.fillText(`Char Frame: ${player.currentFrame + 1}/${player.frames[player.state]}`, 20, 30);
                if (player.state === 'SHIELD') {
                    ctx.fillText(`Eff Frame: ${player.shield.currentFrame + 1}/${player.shield.totalFrames}`, 20, 55);
                }
            }

            update();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>