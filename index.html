<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정수협객: 도검 산림 (물리 동기화 디테일)</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background: #000; border: 5px solid #2e7d32; max-width: 95vw; max-height: 95vh; object-fit: contain; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600;
        canvas.height = 900;

        const imgs = {
            run: new Image(), rising: new Image(), falling: new Image(),
            jumpEff: new Image(), bgFar: new Image(), bgNear: new Image()
        };
        imgs.run.src = 'assets/run_sheet.png';
        imgs.rising.src = 'assets/rising_sheet.png';
        imgs.falling.src = 'assets/falling_sheet.png';
        imgs.jumpEff.src = 'assets/jump_effect_sheet.png'; 
        imgs.bgFar.src = 'assets/bg_far.png';
        imgs.bgNear.src = 'assets/bg_near.png';

        const player = {
            x: 350, y: 0, width: 125, height: 125,
            vy: 0, gravity: 0.4, thrust: -1.2, isPressing: false,
            state: 'RUN', currentFrame: 0, totalFrames: 6,
            frameWidth: 256, frameHeight: 256,
            tickCount: 0, ticksPerFrame: 6, animDir: 1
        };

        let jumpEffects = [];
        const background = { farX: 0, farSpeed: 1, nearX: 0, nearSpeed: 4 };

        function createJumpEffect(px, py, pw, ph) {
            const effSize = 130; 
            jumpEffects.push({
                x: px + (pw / 2) - (effSize / 2), 
                y: py + ph - (effSize / 2) - 15, // 위치 미세조정 포인트
                size: effSize,
                currentFrame: 0, totalFrames: 6,
                tickCount: 0, ticksPerFrame: 3
            });
        }

        // [변경] 마우스 클릭 시에는 이펙트를 만들지 않고 '상태'만 변경함
        window.addEventListener('mousedown', () => player.isPressing = true);
        window.addEventListener('mouseup', () => player.isPressing = false);

        function update() {
            background.farX -= background.farSpeed; if (background.farX <= -canvas.width) background.farX = 0;
            background.nearX -= background.nearSpeed; if (background.nearX <= -canvas.width) background.nearX = 0;

            if (player.isPressing) player.vy += player.thrust;
            player.vy += player.gravity;
            player.y += player.vy;

            const groundY = canvas.height - player.height - 50; 
            let newState = 'RUN';

            if (player.y >= groundY) {
                player.y = groundY; player.vy = 0; newState = 'RUN';
            } else {
                newState = (player.vy < 0) ? 'RISING' : 'FALLING';
            }

            // [핵심] 상태 전이 포착 (State Transition)
            // 예전 상태가 RISING이 아니었는데, 지금 RISING이 되었다면? = "실제로 솟구치기 시작한 순간!"
            if (player.state !== newState) {
                if (newState === 'RISING') {
                    createJumpEffect(player.x, player.y, player.width, player.height);
                }
                player.state = newState;
                player.currentFrame = 0;
                player.tickCount = 0;
                player.animDir = 1;
            }

            // 애니메이션 업데이트 (캐릭터)
            player.tickCount++;
            if (player.tickCount > player.ticksPerFrame) {
                player.tickCount = 0;
                if (player.state === 'RISING') {
                    if (player.currentFrame < player.totalFrames - 1) player.currentFrame++;
                } else if (player.state === 'FALLING') {
                    player.currentFrame += player.animDir;
                    if (player.currentFrame >= player.totalFrames - 1) { player.currentFrame = player.totalFrames - 1; player.animDir = -1; }
                    if (player.currentFrame <= 0) { player.currentFrame = 0; player.animDir = 1; }
                } else {
                    player.currentFrame = (player.currentFrame + 1) % player.totalFrames;
                }
            }

            // 애니메이션 업데이트 (이펙트)
            for (let i = jumpEffects.length - 1; i >= 0; i--) {
                let eff = jumpEffects[i];
                eff.tickCount++;
                if (eff.tickCount > eff.ticksPerFrame) {
                    eff.tickCount = 0;
                    eff.currentFrame++;
                    if (eff.currentFrame >= eff.totalFrames) jumpEffects.splice(i, 1);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(imgs.bgFar, background.farX, 0, canvas.width, canvas.height);
            ctx.drawImage(imgs.bgFar, background.farX + canvas.width, 0, canvas.width, canvas.height);
            ctx.drawImage(imgs.bgNear, background.nearX, 0, canvas.width, canvas.height);
            ctx.drawImage(imgs.bgNear, background.nearX + canvas.width, 0, canvas.width, canvas.height);

            jumpEffects.forEach(eff => {
                if (imgs.jumpEff.complete) {
                    ctx.drawImage(imgs.jumpEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size);
                }
            });

            let currentSheet = (player.state === 'RISING') ? imgs.rising : (player.state === 'FALLING' ? imgs.falling : imgs.run);
            if (currentSheet.complete) {
                ctx.drawImage(currentSheet, player.currentFrame * player.frameWidth, 0, player.frameWidth, player.frameHeight, player.x, player.y, player.width, player.height);
            }

            update();
            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>