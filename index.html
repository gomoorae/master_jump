<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정수협객: 도검 산림 (v2.1 UI 최적화)</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background: #0a0a0a; border: 5px solid #5d4037; box-shadow: 0 0 20px rgba(0,255,0,0.2); cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600;
        canvas.height = 900;

        // 1. 에셋 로딩
        const imgs = {
            rising: new Image(), falling: new Image(), jumpEff: new Image(),
            trap: new Image(), deflect: new Image(), hitEff: new Image(),
            axe: new Image(), spear: new Image(), sword: new Image(),
            wall: new Image(), ceiling: new Image(), 
            optionBtn: new Image(), bgmOn: new Image(), bgmOff: new Image(),
            dead: new Image()
        };

        imgs.rising.src = 'assets/rising_sheet.png';
        imgs.falling.src = 'assets/falling_sheet.png';
        imgs.jumpEff.src = 'assets/jump_effect_sheet.png'; 
        imgs.axe.src = 'assets/axe.png'; imgs.spear.src = 'assets/spear.png'; imgs.sword.src = 'assets/sword.png'; 
        imgs.trap.src = 'assets/trap_asset.png'; imgs.deflect.src = 'assets/deflect_sheet.png'; imgs.hitEff.src = 'assets/hit_effect_sheet.png';
        imgs.wall.src = 'assets/bg_wall.png'; imgs.ceiling.src = 'assets/bg_ceiling.png';
        imgs.optionBtn.src = 'assets/option_btn.png';
        imgs.bgmOn.src = 'assets/bgm_on.png';
        imgs.bgmOff.src = 'assets/bgm_off.png';
        imgs.dead.src = 'assets/dead_sheet.png';

        // 2. 오디오 및 시스템 변수
        const bgm = new Audio('assets/bgm.mp3');
        const gameOverSfx = new Audio('assets/gameover.mp3');
        bgm.loop = true;
        let volumeSteps = 4;
        let lastVolumeSteps = 4;
        bgm.volume = volumeSteps / 8;
        gameOverSfx.volume = bgm.volume;

        let isPaused = false;
        let isClear = false;
        let isGameOver = false;
        let shakeAmount = 0;
        let stageFrameCount = 0;
        const TOTAL_STAGE_TIME = 180 * 60; // 3분

        // 3. 물리 및 환경 수치 (정수's v1.9 수치)
        const TRAP_HEIGHT = 80; const TRAP_SPEED = 6; const OBSTACLE_GRAVITY = 0.8; const AXE_GRAVITY = 0.09;
        const background = { wallX: 0, wallSpeed: 2, ceilingX: 0, ceilingSpeed: 8, trapX: 0 };
        const player = {
            x: 350, y: 100, drawWidth: 125, drawHeight: 125,
            hitboxWidth: 50, hitboxHeight: 90, hitboxOffsetX: 25, hitboxOffsetY: 15,
            vy: 0, gravity: 0.4, thrust: -1.2, isPressing: false,
            state: 'FALLING', currentFrame: 0, tickCount: 0, ticksPerFrame: 5, animDir: 1,
            frames: { RISING: 6, FALLING: 6, DEFLECT: 3, DEAD: 6 },
            ceilingStunTimer: 0, jingi: 8, maxJingi: 8, jingiRecoverTick: 0
        };

        const ui = {
            optBtn: { x: 20, y: 800, w: 70, h: 70 },
            // ★ [정수 수치 적용] 진기 바
            jingiBar: { x: 30, y: 30, segW: 20, segH: 20, gap: 5, color: '#00ffcc' },
            volBar: { x: 700, y: 405, w: 320, h: 30, gap: 5 },
            soundIcon: { x: 580, y: 380, size: 80 }
        };

        let jumpEffects = []; let hitEffects = []; let obstacles = [];
        let obstacleTrails = []; let envParticles = [];

        // --- 기능 함수 ---
        function initGame() {
            isPaused = false; isClear = false; isGameOver = false;
            stageFrameCount = 0; shakeAmount = 0;
            player.y = 100; player.vy = 0; player.jingi = player.maxJingi;
            player.state = 'FALLING'; player.currentFrame = 0;
            obstacles = []; obstacleTrails = []; envParticles = [];
            if(volumeSteps > 0) { bgm.currentTime = 0; bgm.play(); }
        }

        function createJumpEffect(px, py, pw, ph) { jumpEffects.push({ x: px + (pw/2)-65-15, y: py+ph-65-19, size: 130, currentFrame: 0, totalFrames: 6, tickCount: 0, ticksPerFrame: 3 }); }
        function createHitEffect(x, y) { hitEffects.push({ x: x, y: y - 50, size: 100, currentFrame: 0, totalFrames: 5, tickCount: 0, ticksPerFrame: 2 }); }
        
        function createEnvBurst(x, y, isCeiling) {
            for (let i = 0; i < 15; i++) { envParticles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 10, vy: isCeiling ? (Math.random() * 5 + 2) : (Math.random() * -5 - 2), size: Math.random() * 4 + 2, color: '#ffffff', life: 1.0, decay: Math.random() * 0.05 + 0.02 }); }
            if (!isGameOver) shakeAmount = 15; // ★ 사망 시에는 흔들림 추가 금지
            if (player.jingi > 0) player.jingi--;
        }
        
        function createTrail(x, y, type) { obstacleTrails.push({ x: x, y: y, alpha: 0.6, size: Math.random() * 4, color: (type === 'SPEAR') ? '#ffffff' : '#aaccff', speedX: Math.random() * 2, life: 1.0 }); }
        
        function spawnObstacle() {
            let progress = stageFrameCount / TOTAL_STAGE_TIME;
            let currentSpawnProb = 0.03 + (0.04 * progress); // 난이도 곡선
            if (Math.random() < currentSpawnProb) {
                const types = ['AXE', 'SPEAR', 'SWORD'];
                const selectedType = types[Math.floor(Math.random() * types.length)];
                let obsData = { x: canvas.width, angle: 0, isDeflected: false, vx: 0, vy: 0, type: selectedType, rotationSpeed: 0.18 };
                switch(selectedType) {
                    case 'AXE': obsData.size = 60; obsData.speed = 7 + Math.random() * 3; obsData.y = canvas.height - TRAP_HEIGHT - 400; obsData.vy = -6 - Math.random() * 3; obsData.img = imgs.axe; break;
                    case 'SPEAR': obsData.size = 90; obsData.speed = 12 + Math.random() * 4; obsData.y = Math.random() * (canvas.height - TRAP_HEIGHT - 150); obsData.img = imgs.spear; break;
                    case 'SWORD': obsData.size = 70; obsData.speed = 10 + Math.random() * 3; obsData.y = player.y + (player.drawHeight / 2) - 35; obsData.img = imgs.sword; break;
                }
                obstacles.push(obsData);
            }
        }

        // --- 입력 처리 ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
            const cX = canvas.width/2; const cY = canvas.height/2;

            if (isGameOver) {
                if (mx >= cX - 100 && mx <= cX + 100 && my >= cY + 80 && my <= cY + 140) initGame();
                return;
            }
            if (isPaused) {
                if (mx >= ui.soundIcon.x && mx <= ui.soundIcon.x + ui.soundIcon.size && my >= ui.soundIcon.y && my <= ui.soundIcon.y + ui.soundIcon.size) {
                    if (volumeSteps > 0) { lastVolumeSteps = volumeSteps; volumeSteps = 0; bgm.pause(); } 
                    else { volumeSteps = lastVolumeSteps; bgm.volume = volumeSteps / 8; bgm.play().catch(() => {}); }
                    gameOverSfx.volume = bgm.volume; return;
                }
                if (mx >= ui.volBar.x && mx <= ui.volBar.x + ui.volBar.w && my >= ui.volBar.y && my <= ui.volBar.y + ui.volBar.h) {
                    volumeSteps = Math.ceil((mx - ui.volBar.x) / (ui.volBar.w / 8)); 
                    bgm.volume = volumeSteps / 8; gameOverSfx.volume = bgm.volume;
                    if (volumeSteps > 0) bgm.play().catch(() => {}); else bgm.pause(); return;
                }
                if (mx >= cX - 100 && mx <= cX + 100 && my >= cY + 80 && my <= cY + 140) { isPaused = false; return; }
                return;
            }
            if (mx >= ui.optBtn.x && mx <= ui.optBtn.x + ui.optBtn.w && my >= ui.optBtn.y && my <= ui.optBtn.y + ui.optBtn.h) { isPaused = true; player.isPressing = false; return; }
            if (!isGameOver && player.ceilingStunTimer <= 0) { player.isPressing = true; if(volumeSteps > 0) bgm.play().catch(() => {}); }
        });

        window.addEventListener('mouseup', () => { player.isPressing = false; });
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !isGameOver) isPaused = !isPaused; });

        // --- 업데이트 로직 ---
        function update() {
            if (isPaused || isClear) return;

            // ★ 게임 오버 처리 (흔들림 강제 정지)
            if (player.jingi <= 0 && !isGameOver) {
                isGameOver = true; shakeAmount = 0; // 흔들림 즉시 멈춤
                bgm.pause(); gameOverSfx.play();
                player.state = 'DEAD'; player.currentFrame = 0;
            }

            if (isGameOver) {
                const deadStopY = canvas.height - (TRAP_HEIGHT / 2) - (player.drawHeight / 2);
                if (player.y < deadStopY) { player.vy += 0.5; player.y += player.vy; } else { player.y = deadStopY; player.vy = 0; }
                player.tickCount++;
                if (player.tickCount > player.ticksPerFrame) { player.tickCount = 0; if (player.currentFrame < player.frames.DEAD - 1) player.currentFrame++; }
                return;
            }

            stageFrameCount++;
            if (stageFrameCount >= TOTAL_STAGE_TIME) { isClear = true; bgm.pause(); return; }

            // 진기 회복 시스템
            if (player.jingi < player.maxJingi) {
                player.jingiRecoverTick++;
                if (player.jingiRecoverTick >= 180) { player.jingi++; player.jingiRecoverTick = 0; }
            }

            // 물리 및 충돌 로직
            background.wallX -= background.wallSpeed; if (background.wallX <= -2560) background.wallX = 0;
            background.ceilingX -= background.ceilingSpeed; if (background.ceilingX <= -2560) background.ceilingX = 0;
            background.trapX -= TRAP_SPEED; if (background.trapX <= -canvas.width) background.trapX = 0;

            if (player.ceilingStunTimer > 0) { player.ceilingStunTimer--; player.isPressing = false; }
            if (player.isPressing) player.vy += player.thrust; player.vy += player.gravity; player.y += player.vy;

            if (player.y < 40) { if (player.ceilingStunTimer <= 0) createEnvBurst(player.x + player.drawWidth / 2, 40, true); player.y = 40; player.vy = 0.5; player.ceilingStunTimer = 10; }
            if (player.y + player.drawHeight > canvas.height - TRAP_HEIGHT && player.vy >= 0) { createEnvBurst(player.x + player.drawWidth / 2, canvas.height - TRAP_HEIGHT, false); player.vy = -10; player.state = 'RISING'; player.currentFrame = 0; player.tickCount = 0; player.animDir = 1; createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight); }

            spawnObstacle();
            const phX = player.x + player.hitboxOffsetX; const phY = player.y + player.hitboxOffsetY;
            obstacles.forEach((obs) => {
                if (!obs.isDeflected) {
                    obs.x -= obs.speed;
                    if (obs.type === 'AXE') { obs.y += obs.vy; obs.vy += AXE_GRAVITY; obs.angle -= 0.18; }
                    if (obs.type === 'SPEAR' || obs.type === 'SWORD') { if (Math.random() < 1) createTrail(obs.x + 10, obs.y + obs.size/2, obs.type); }
                    const oCX = obs.x + obs.size / 2; const oCY = obs.y + obs.size / 2;
                    const isHit = (phX < oCX + 20 && phX + 50 > oCX - 20 && phY < oCY + 20 && phY + 90 > oCY - 20);
                    if (isHit && player.state !== 'DEFLECT') { 
                        if (player.jingi > 0) player.jingi--;
                        obs.isDeflected = true; obs.vx = 10 + Math.random() * 5; obs.vy = -15 - Math.random() * 5; obs.rotationSpeed = (Math.random() > 0.5 ? 1 : -1) * 0.4;
                        createHitEffect(oCX, oCY); player.state = 'DEFLECT'; player.currentFrame = 0; player.tickCount = 0; 
                    }
                } else { obs.x += obs.vx; obs.y += obs.vy; obs.vy += OBSTACLE_GRAVITY; obs.angle += obs.rotationSpeed; }
            });

            // 이펙트 업데이트
            if (shakeAmount > 0) { shakeAmount -= 0.8; if (shakeAmount < 0) shakeAmount = 0; }
            for (let i = envParticles.length - 1; i >= 0; i--) { let p = envParticles[i]; p.x += p.vx; p.y += p.vy; p.life -= p.decay; if (p.life <= 0) envParticles.splice(i, 1); }
            for (let i = obstacleTrails.length - 1; i >= 0; i--) { let p = obstacleTrails[i]; p.x += p.speedX; p.life -= 0.13; if (p.life <= 0) obstacleTrails.splice(i, 1); }
            if (player.state !== 'DEFLECT') { let newState = (player.vy < 0) ? 'RISING' : 'FALLING'; if (player.state !== newState) { if (newState === 'RISING') createJumpEffect(player.x, player.y, player.drawWidth, player.drawHeight); player.state = newState; player.currentFrame = 0; player.tickCount = 0; player.animDir = 1; } }
            player.tickCount++; const charTotalFrames = player.frames[player.state];
            if (player.tickCount > player.ticksPerFrame) { player.tickCount = 0; if (player.state === 'DEFLECT') { player.currentFrame++; if (player.currentFrame >= charTotalFrames) { player.state = (player.vy < 0) ? 'RISING' : 'FALLING'; player.currentFrame = 0; player.animDir = 1; } } else if (player.state === 'FALLING') { player.currentFrame += player.animDir; if (player.currentFrame >= charTotalFrames - 1) { player.currentFrame = charTotalFrames - 1; player.animDir = -1; } else if (player.currentFrame <= 0) { player.currentFrame = 0; player.animDir = 1; } } else if (player.state === 'RISING') { if (player.currentFrame < charTotalFrames - 1) player.currentFrame++; } }
            [jumpEffects, hitEffects].forEach(arr => { for (let i = arr.length - 1; i >= 0; i--) { let eff = arr[i]; eff.tickCount++; if (eff.tickCount > eff.ticksPerFrame) { eff.tickCount = 0; eff.currentFrame++; if (eff.currentFrame >= eff.totalFrames) arr.splice(i, 1); } } });
            for (let i = obstacles.length - 1; i >= 0; i--) { if (obstacles[i].x < -200 || obstacles[i].x > canvas.width + 2500 || obstacles[i].y > canvas.height + 200) obstacles.splice(i, 1); }
        }

        // --- 렌더링 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            if (shakeAmount > 0) ctx.translate(Math.random() * shakeAmount - shakeAmount / 2, Math.random() * shakeAmount - shakeAmount / 2);
            if (imgs.wall.complete) { ctx.drawImage(imgs.wall, background.wallX, canvas.height - 850, 2560, 850); ctx.drawImage(imgs.wall, background.wallX + 2560, canvas.height - 850, 2560, 850); }
            obstacleTrails.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0;
            envParticles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); }); ctx.globalAlpha = 1.0;
            jumpEffects.forEach(eff => { if (imgs.jumpEff.complete) ctx.drawImage(imgs.jumpEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size); });
            let curS = imgs[player.state.toLowerCase()];
            if (curS && curS.complete) ctx.drawImage(curS, player.currentFrame * 256, 0, 256, 256, player.x, player.y, player.drawWidth, player.drawHeight);
            obstacles.forEach(obs => { ctx.save(); ctx.translate(obs.x + obs.size/2, obs.y + obs.size/2); if (obs.type === 'AXE' || obs.isDeflected) ctx.rotate(obs.angle); if (obs.img.complete) ctx.drawImage(obs.img, -obs.size/2, -obs.size/2, obs.size, obs.size); ctx.restore(); });
            hitEffects.forEach(eff => { if (imgs.hitEff.complete) ctx.drawImage(imgs.hitEff, eff.currentFrame * 256, 0, 256, 256, eff.x, eff.y, eff.size, eff.size); });
            if (imgs.trap.complete) { ctx.drawImage(imgs.trap, background.trapX, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT); ctx.drawImage(imgs.trap, background.trapX + canvas.width, canvas.height - TRAP_HEIGHT, canvas.width, TRAP_HEIGHT); }
            if (imgs.ceiling.complete) { ctx.drawImage(imgs.ceiling, background.ceilingX, 0, 2560, 80); ctx.drawImage(imgs.ceiling, background.ceilingX + 2560, 0, 2560, 80); }
            ctx.restore();

            // ★ 진기 바
            const jb = ui.jingiBar;
            for (let i = 0; i < player.maxJingi; i++) {
                ctx.fillStyle = (i < player.jingi) ? jb.color : 'rgba(255, 255, 255, 0.1)';
                ctx.strokeStyle = (i < player.jingi) ? 'white' : 'rgba(255, 255, 255, 0.2)';
                const rx = jb.x + i * (jb.segW + jb.gap);
                ctx.fillRect(rx, jb.y, jb.segW, jb.segH); ctx.strokeRect(rx, jb.y, jb.segW, jb.segH);
            }

            // ★ 스테이지 진행도 바 (Progress Bar)
            const barW = (jb.segW * 8 + jb.gap * 7); // 진기 바 8칸 너비와 맞춤
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(jb.x, jb.y + jb.segH + 12, barW, 6);
            ctx.fillStyle = 'orange';
            ctx.fillRect(jb.x, jb.y + jb.segH + 12, barW * (stageFrameCount / TOTAL_STAGE_TIME), 6);

            if (imgs.optionBtn.complete) ctx.drawImage(imgs.optionBtn, ui.optBtn.x, ui.optBtn.y, ui.optBtn.w, ui.optBtn.h);

            // 게임 오버 레이어
            if (isGameOver) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cX = canvas.width/2; const cY = canvas.height/2;
                ctx.fillStyle = 'white'; ctx.font = 'bold 80px Arial'; ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', cX, cY - 20);
                ctx.fillStyle = '#5d4037'; ctx.fillRect(cX - 100, cY + 80, 200, 60);
                ctx.fillStyle = 'white'; ctx.font = 'bold 28px Arial'; ctx.fillText('RETRY', cX, cY + 122);
            }

            // 스테이지 클리어 레이어
            if (isClear) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white'; ctx.font = 'bold 80px Arial'; ctx.textAlign = 'center';
                ctx.fillText('STAGE CLEAR!', canvas.width/2, canvas.height/2);
            }

            // 옵션 메뉴
            if (isPaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cX = canvas.width/2; const cY = canvas.height/2;
                ctx.fillStyle = '#2d1b0d'; ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 8;
                ctx.strokeRect(cX - 300, cY - 200, 600, 400); ctx.fillRect(cX - 300, cY - 200, 600, 400);
                const sImg = (volumeSteps === 0) ? imgs.bgmOff : imgs.bgmOn;
                if (sImg.complete) ctx.drawImage(sImg, ui.soundIcon.x, ui.soundIcon.y, ui.soundIcon.size, ui.soundIcon.size);
                const stepW = (ui.volBar.w / 8) - ui.volBar.gap;
                for (let i = 0; i < 8; i++) { ctx.fillStyle = (i < volumeSteps) ? '#f1c40f' : '#1a1008'; ctx.fillRect(ui.volBar.x + i * (stepW + ui.volBar.gap), ui.volBar.y, stepW, ui.volBar.h); }
                
                // ★ RESUME 버튼 중앙 정렬 수정
                ctx.fillStyle = '#5d4037'; ctx.fillRect(cX - 100, cY + 80, 200, 60);
                ctx.fillStyle = 'white'; ctx.font = 'bold 28px Arial'; ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; // 수직 중앙 정렬
                ctx.fillText('RESUME', cX, cY + 112); // 정중앙 좌표 보정
                ctx.textBaseline = 'alphabetic'; // 다른 텍스트 영향 방지
            }

            update(); requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>